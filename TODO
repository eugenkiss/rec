- CallClosure Anzahl der Argumente ist überflüssig -> entfernen, da lamba-Ausdruck
  immer nur einen  Parameter hat bei uns
- HAp zu CAp für Closure Application
- Irgendwo hinschreiben, dass If Konstruktor und Ap eigenltich nicht zwingend benötigt
  werden, da If mit Chruch und statt Ap Immer HAp benutzt werden könnte.
- Code aufräumen ab GOTO!
- Mit Grep nach TODO's suchen!
- Lint drüber laufen lassen

- find explanation of encoding of lists like I use, so that I can explain it
  with my own words.

- write evaluator that spits out configurations as json list,
  so that I can write a javascript app (maybe even dart or kotlin?)
  that graphically shows code, content of certain vars (like pc,fp)
  as well as stack (with distinguished stack frames as well es frame
  pointer arrow) and heap. If heap resp. stack entry is an adress
  of some sort (to code or to another stack/heap entry), try to
  draw arrow to that location. Be able to step through the configs
  and animate.
  in presentation make the case for need of stack frames (patholocigal
  cases e.g. recursion) and heap (upvar/downvar problem)


FUTURE
======

- duplizierte Funktionsdefinitionen -> Fehler
  -> write Test Case
- keine main definition -> Fehler
  -> write Test Case
- beim 2. Pass: Variable, die weder freie noch gebundene Variable ist -> Fehler
  (dazu aber Prelude vor dem 2.Pass hinzufügen!)
  -> write Test Case
- alpha reduction: wenn eine Funktion lamret,IF,GOTO etc. heißt, dann ihr einen
  neuen Namen geben, damit sie nicht mit der lamret section kollidiert (1st
  pass)
  -> write Test Case

- Prelude! (map, cons etc.) Falls aber eine Funktion mit demselben Namen schon
  existert, dann prelude definition *nicht* verwenden. Und prelude definitionen
  nur einfügen, wenn sie auch benutzt werden!
    http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.2
    http://programmingpraxis.com/contents/standard-prelude/
    http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html
  Benutze Template Haskell um stdlib zur compilierzeit in die korrekte Stelle
  einzufügen.
- Template Haskell auch für Testfälle nutzen
- Evaluator soll bei nichtFinden keine Exception verursachen (z.B. zu oft Pushen),
  sondern sich so verhalten, wie die Übersetzung mit Cantor würde (also einfach
  0 als Pop ergebnis wenn stack leer).