- Irgendwo hinschreiben, dass If Konstruktor und Ap eigenltich nicht zwingend benötigt
  werden, da If mit Chruch und statt Ap Immer HAp benutzt werden könnte.
- Code aufräumen ab GOTO!
- Mit Grep nach TODO's suchen!
- Lint drüber laufen lassen

- find explanation of encoding of lists like I use, so that I can explain it
  with my own words.


FUTURE
======

- duplizierte Funktionsdefinitionen -> Fehler
  -> write Test Case
- keine main definition -> Fehler
  -> write Test Case
- beim 2. Pass: Variable, die weder freie noch gebundene Variable ist -> Fehler
  (dazu aber Prelude vor dem 2.Pass hinzufügen!)
  -> write Test Case
- alpha reduction: wenn eine Funktion lamret,IF,GOTO etc. heißt, dann ihr einen
  neuen Namen geben, damit sie nicht mit der lamret section kollidiert (1st
  pass)
  -> write Test Case

- Prelude! (map, cons etc.) Falls aber eine Funktion mit demselben Namen schon
  existert, dann prelude definition *nicht* verwenden. Und prelude definitionen
  nur einfügen, wenn sie auch benutzt werden!
    http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.2
    http://programmingpraxis.com/contents/standard-prelude/
    http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html
  Benutze Template Haskell um stdlib zur compilierzeit in die korrekte Stelle
  einzufügen.
- Template Haskell auch für Testfälle nutzen
- Syntaktischer Zucker für Listen?
    [1,2,3] => cons, 2 : [3,4] => cons(2,[3,4])
    [1] ++ [2] => append([1],[2])
- Let bindings? (Let mittels Church encoding?) (aber bitte recursive)
- Evaluator soll bei nichtFinden keine Exception verursachen (z.B. zu oft Pushen),
  sondern sich so verhalten, wie die Übersetzung mit Cantor würde (also einfach
  0 als Pop ergebnis wenn stack leer).