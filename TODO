- Beispiele mit syntaktischem Zucker verbessern!
- Code aufräumen!
- Mit Grep nach TODO's suchen!
- Lint drüber laufen lassen

- use landin paper
- find explanation of encoding of lists like I use, so that I can explain it
  with my own words.

- create documentation code.pdf and look that it is correctlu formatted

- Dokumentieren:
  - \f g y. ist syntaktischer zuker für \f.\g.\y.
  - succ()(a, b, c) ist syntaktischer zucker für succ()(a)(b)(c)
  - succ := bla ist syntaktischer Zucker für succ() := bla
  - succ ist syntaktischer Zucker für succ(), falls succ toplevel fkt.
    mit 0 Parametern ist
    Das gilt insbesondere für eine Applikation succ(a,b), die wie folgt zu
    interpretieren ist: succ()(a,b)
  - Direktes zuweisen von top-level funktionen als parameter ermöglichen, sodass
    nicht immer in einen lambda-ausdruck gewrappt werden muss
    succ ist also syntaktischer zucker für \x1.\x2. ... \xn. succ(x1,x2,...,xn)
    falls succ n parameter erhält
    Falls n=0, dann steht succ für succ()
      (succ(a,b,c) steht in dem Fall dann für succ()(a,b,c)))
    Falls n=3
      succ == succ() == \a b c. succ(a,b,c)
      succ(a) == \b c. succ(a,b,c)
      succ(a, b) == \c. succ(a,b,c)
      succ(a, b, c) == succ(a,b,c)
      succ(a, b, c, d) == succ(a,b,c)(d)
      ...


FUTURE
======

- CLOSURIZE zu MAKE_CLOSURE!
- Prelude! (map, cons etc.) Falls aber eine Funktion mit demselben Namen schon
  existert, dann prelude definition *nicht* verwenden. Und prelude definitionen
  nur einfügen, wenn sie auch benutzt werden!
    http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.2
    http://programmingpraxis.com/contents/standard-prelude/
    http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html
  Benutze Template Haskell um stdlib zur compilierzeit in die korrekte Stelle
  einzufügen.
- Template Haskell auch für Testfälle nutzen
- Syntaktischer Zucker für Listen?
    [1,2,3] => cons, 2 : [3,4] => cons(2,[3,4])
    [1] ++ [2] => append([1],[2])
- Let bindings? (Let mittels Church encoding?)
- alpha reduction: wenn eine Funktion lamret,IF,GOTO etc. heißt, dann ihr einen
  neuen Namen geben, damit sie nicht mit der lamret section kollidiert (1st
  pass)

