- buggy churchlists.rec in tests übernehmen
- Code aufräumen!
- Mit Grep nach TODO's suchen!
- Lint drüber laufen lassen

- use landin paper
- find explanation of encoding of lists like I use, so that I can explain it
  with my own words.

- create documentation code.pdf and look that it is correctlu formatted

- Dokumentieren:
  - \f g y. ist syntaktischer zuker für \f.\g.\y.
  - succ()(a, b, c) ist syntaktischer zucker für succ()(a)(b)(c)
  - succ := bla ist syntaktischer Zucker für succ() := bla
  - succ ist syntaktischer Zucker für succ(), falls succ toplevel fkt.
    Das gilt insbesondere für eine Applikation succ(a,b), die wie folgt zu
    interpretieren ist: succ()(a,b)


FUTURE
======

- CLOSURIZE zu MAKE_CLOSURE!
- Prelude! (map, cons etc.) Falls aber eine Funktion mit demselben Namen schon
  existert, dann prelude definition *nicht* verwenden. Und prelude definitionen
  nur einfügen, wenn sie auch benutzt werden!
    http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.2
    http://programmingpraxis.com/contents/standard-prelude/
    http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html
  Benutze Template Haskell um stdlib zur compilierzeit in die korrekte Stelle
  einzufügen.
- Template Haskell auch für Testfälle nutzen
- Syntaktischer Zucker für Listen?
    [1,2,3] => cons, 2 : [3,4] => cons(2,[3,4])
    [1] ++ [2] => append([1],[2])
- Let bindings? (Let mittels Church encoding?)
- alpha reduction: wenn eine Funktion lamret,IF,GOTO etc. heißt, dann ihr einen
  neuen Namen geben, damit sie nicht mit der lamret section kollidiert (1st
  pass)

